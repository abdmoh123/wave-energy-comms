#include <ArduinoLowPower.h>
#include <SPI.h>
#include <LoRa.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>

const double MAX_EMF_VOLTAGE = 20.0;
const double EMF_MAX_FREQUENCY = 15.0;
const double SAMPLE_PERIOD = 1.0 / (10.0 * EMF_MAX_FREQUENCY); // x2 satisfies nyquist
double time = 0.0; // for simulating emf voltage

Adafruit_MPU6050 mpu;
Adafruit_Sensor *acc_sensor, *gyro_sensor, *temp_sensor;
// variables to cancel out any errors in measurements
double x_rot_error = 0.0;
double y_rot_error = 0.0;
double z_rot_error = 0.0;
double x_acc_error = 0.0;
double y_acc_error = 0.0;
double z_acc_error = 0.0;

void setup() {
  Serial.begin(9600);
  while (!Serial);

  // halts program if lora failed to start
  if (!LoRa.begin(868E6)) {
    Serial.println("Starting LoRa failed!");
    while (1) { LowPower.deepSleep(3600000); } // deep sleeps (1h) to save power
  }
  Serial.println("LoRa successful!");
  
  // tries to initialize mpu6050 sensor
  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050 chip");
    while (1) { LowPower.deepSleep(3600000); } // deep sleeps (1h) to save power
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G); // set accelerometer range to +-8G
  mpu.setGyroRange(MPU6050_RANGE_500_DEG); // set gyro range to +- 500 deg/s
  mpu.setFilterBandwidth(MPU6050_BAND_5_HZ); // set low pass filter bandwidth to 5 Hz (improves stability)

  // gets data from the sensor for calibration
  acc_sensor = mpu.getAccelerometerSensor();
  gyro_sensor = mpu.getGyroSensor();
  sensors_event_t acc_event, gyro_event;
  acc_sensor->getEvent(&acc_event);
  gyro_sensor->getEvent(&gyro_event);
  // sets the error values to calibrate the sensors
  x_acc_error = acc_event.acceleration.x - 9.81; // ignores influence of gravity
  y_acc_error = acc_event.acceleration.y;
  z_acc_error = acc_event.acceleration.z;
  x_rot_error = gyro_event.gyro.x;
  y_rot_error = gyro_event.gyro.y;
  z_rot_error = gyro_event.gyro.z;
}

double gen_voltage(double time) {
  /* Generates a simulated value for emf voltage generated by generator */

  // generates a value between 15 and 7.5 Hz (varying frequency)
  double frequency_value = EMF_MAX_FREQUENCY * ((sin(PI * time) / 4) + 0.75); // frequency changes every 2 cycles
  double voltage = MAX_EMF_VOLTAGE * sin(frequency_value * 2 * PI * time);

  // prints voltage data (for plotting)
  Serial.print("emf_volt:");
  Serial.print(voltage);
  Serial.print(",");
  Serial.print("t:");
  Serial.println(time);

  return voltage;
}

void loop() {
  // generates and prints simulated emf voltage
  double emf_volt = gen_voltage(time);
    
  // get new sensor events with the readings
  sensors_event_t accelerometer, gyroscope, thermometer;
  mpu.getEvent(&accelerometer, &gyroscope, &thermometer);
  
  // gets x y z acceleration
  double x_acc = accelerometer.acceleration.x;
  double y_acc = accelerometer.acceleration.y;
  double z_acc = accelerometer.acceleration.z;
  // prints out the values
  Serial.print("x_acc:");
  Serial.print(x_acc);
  Serial.print(",");
  Serial.print("y_acc:");
  Serial.print(y_acc);
  Serial.print(",");
  Serial.print("z_acc:");
  Serial.println(z_acc);
  
  // gets x y z rotation
  double x_rot = gyroscope.gyro.x - x_rot_error;
  double y_rot = gyroscope.gyro.y - y_rot_error;
  double z_rot = gyroscope.gyro.z - z_rot_error;
  // prints out the values
  Serial.print("x_rot:");
  Serial.print(x_rot);
  Serial.print(",");
  Serial.print("y_rot:");
  Serial.print(y_rot);
  Serial.print(",");
  Serial.print("z_rot:");
  Serial.println(z_rot);

  // gets and prints the temperature
  double temp = thermometer.temperature;
  Serial.print("temp:");
  Serial.println(temp);

  Serial.println("\nSending packet...");
  // sends packet with data
  LoRa.beginPacket();
  LoRa.print(emf_volt);
  LoRa.print(" "); // space is used to separate each data value
  LoRa.print(x_acc);
  LoRa.print(" ");
  LoRa.print(x_rot);
  LoRa.print(" ");
  LoRa.print(y_acc);
  LoRa.print(" ");
  LoRa.print(y_rot);
  LoRa.print(" ");
  LoRa.print(z_acc);
  LoRa.print(" ");
  LoRa.print(z_rot);
  LoRa.endPacket();
  Serial.println("Packet sent!\n");

  // advances counter
  time += SAMPLE_PERIOD;
  // delays/waits for 1/15s (Sample period * 1000 due to s -> ms conversion)
  delay(SAMPLE_PERIOD * 1000);
}
